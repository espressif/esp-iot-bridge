diff --git a/src/core/ipv4/ip4_napt.c b/src/core/ipv4/ip4_napt.c
index afc2695d..5472c5dc 100644
--- a/src/core/ipv4/ip4_napt.c
+++ b/src/core/ipv4/ip4_napt.c
@@ -41,6 +41,10 @@
 
 #if ESP_LWIP && LWIP_IPV4 && IP_NAPT
 
+#ifdef ESP_IDF_LWIP_HOOK_FILENAME
+#include ESP_IDF_LWIP_HOOK_FILENAME
+#endif
+
 #include <assert.h>
 #include <stdbool.h>
 #include <string.h>
@@ -624,6 +628,11 @@ ip_napt_add(u8_t proto, u32_t src, u16_t sport, u32_t dest, u16_t dport, u32_t s
     return mport;
   }
   LWIP_DEBUGF(NAPT_DEBUG, ("ip_napt_add() failed to insert\n"));
+
+#ifdef IP_NAPT_ADD_FAILED_HOOK
+  IP_NAPT_ADD_FAILED_HOOK();
+#endif
+
   return 0;
 }
 
@@ -1069,6 +1078,10 @@ ip_napt_maint(void)
   }
   ip_napt_gc(now, false /* make_room */);
   s_last_now = now;
+
+#ifdef IOT_BRIDGE_NAPT_TABLE_CLEAR
+  IOT_BRIDGE_NAPT_TABLE_CLEAR();
+#endif
 }
 
 static void
@@ -1086,4 +1099,33 @@ ip_napt_get_stats(struct stats_ip_napt *stats)
 }
 #endif /* LWIP_STATS */
 
+#define IP_GET_V4(ipaddr)          (ip_2_ip4(ipaddr))
+
+void ip_napt_table_clear(void)
+{
+    struct netif *each_netif;
+    u16_t i = 0, next = 0;
+    struct ip_napt_entry *t;
+
+    NETIF_FOREACH(each_netif) {
+        if (netif_is_up(each_netif)
+            && !each_netif->napt
+            && !ip_addr_isany(&each_netif->ip_addr)
+            && IP_IS_V4(&each_netif->ip_addr)
+            && !ip4_addr_isloopback(IP_GET_V4(&each_netif->ip_addr))) {
+            /* napt used on another interface, no need for cleanup */
+            return;
+        }
+    }
+
+    uint32_t deleted_count = 0;
+    for (i = napt_list; i != NO_IDX; i = next) {
+        t = NT(i);
+        next = t->next;
+        ip_napt_free(t);
+        deleted_count++;
+    }
+    LWIP_DEBUGF(NAPT_DEBUG, ("deleted napt count=%"PRIu32"\r\n", deleted_count));
+}
+
 #endif /* ESP_LWIP && LWIP_IPV4 && IP_NAPT */
